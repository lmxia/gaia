package utils

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"sync"

	lmmserverless "github.com/SUMMERLm/serverless/api/v1"
	appsv1alpha1 "github.com/lmxia/gaia/pkg/apis/apps/v1alpha1"
	"github.com/lmxia/gaia/pkg/apis/platform/v1alpha1"
	gaiaClientSet "github.com/lmxia/gaia/pkg/generated/clientset/versioned"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime/schema"
	utilerrors "k8s.io/apimachinery/pkg/util/errors"
	utilRuntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/util/retry"
	"k8s.io/klog/v2"

	known "github.com/lmxia/gaia/pkg/common"
)

func DeleteResourceWithRetry(ctx context.Context, dynamicClient dynamic.Interface, restMapper meta.RESTMapper, resource *unstructured.Unstructured) error {
	deletePropagationBackground := metav1.DeletePropagationBackground

	var lastError error
	err := wait.ExponentialBackoffWithContext(ctx, retry.DefaultBackoff, func() (bool, error) {
		restMapping, err := restMapper.RESTMapping(resource.GroupVersionKind().GroupKind(), resource.GroupVersionKind().Version)
		if err != nil {
			lastError = fmt.Errorf("please check whether the advertised apiserver of current child cluster is accessible. %v", err)
			return false, nil
		}

		lastError = dynamicClient.Resource(restMapping.Resource).Namespace(resource.GetNamespace()).
			Delete(context.TODO(), resource.GetName(), metav1.DeleteOptions{PropagationPolicy: &deletePropagationBackground})
		if lastError == nil || (lastError != nil && apierrors.IsNotFound(lastError)) {
			return true, nil
		}
		return false, nil
	})
	if err == nil {
		return nil
	}
	return lastError
}

// copied from k8s.io/apimachinery/pkg/apis/meta/v1/unstructured
func getNestedString(obj map[string]interface{}, fields ...string) string {
	val, found, err := unstructured.NestedString(obj, fields...)
	if !found || err != nil {
		return ""
	}
	return val
}

// copied from k8s.io/apimachinery/pkg/apis/meta/v1/unstructured
// and modified
func setNestedField(u *unstructured.Unstructured, value interface{}, fields ...string) {
	if u.Object == nil {
		u.Object = make(map[string]interface{})
	}
	err := unstructured.SetNestedField(u.Object, value, fields...)
	if err != nil {
		klog.Warningf("failed to set nested field: %v", err)
	}
}

// getStatusCause returns the named cause from the provided error if it exists and
// the error is of the type APIStatus, Otherwise it returns false.
func getStatusCause(err error) ([]metav1.StatusCause, bool) {
	apierr, ok := err.(apierrors.APIStatus)
	if !ok || apierr == nil || apierr.Status().Details == nil {
		return nil, false
	}
	return apierr.Status().Details.Causes, true
}

func GetDeployerCredentials(ctx context.Context, childKubeClientSet kubernetes.Interface, sa string) *corev1.Secret {
	var secret *corev1.Secret
	localCtx, cancel := context.WithCancel(ctx)

	ver, err := childKubeClientSet.Discovery().ServerVersion()
	if err != nil {
		return nil
	}
	// parse saTokenAutoGenerated by server version
	var saTokenAutoGenerated bool
	if saTokenAutoGenerated, err = SATokenAutoGenerated(ver.String()); err != nil {
		return nil
	}

	klog.V(4).Infof("get ServiceAccount %s/%s", known.GaiaSystemNamespace, sa)
	wait.JitterUntilWithContext(localCtx, func(ctx context.Context) {
		secretName := sa
		if saTokenAutoGenerated {
			sa, err := childKubeClientSet.CoreV1().ServiceAccounts(known.GaiaSystemNamespace).Get(ctx, sa, metav1.GetOptions{})
			if err != nil {
				klog.ErrorDepth(5, fmt.Errorf("failed to get ServiceAccount %s/%s: %v", known.GaiaSystemNamespace, sa, err))
				return
			}

			if len(sa.Secrets) == 0 {
				klog.ErrorDepth(5, fmt.Errorf("no secrets found in ServiceAccount %s/%s", known.GaiaSystemNamespace, sa))
				return
			}
			secretName = sa.Secrets[0].Name
		}
		secret, err = childKubeClientSet.CoreV1().Secrets(known.GaiaSystemNamespace).Get(ctx, secretName, metav1.GetOptions{})
		if err != nil {
			klog.ErrorDepth(5, fmt.Errorf("failed to get Secret %s/%s: %v", known.GaiaSystemNamespace, secretName, err))
			return
		}

		cancel()
	}, known.DefaultRetryPeriod, 0.4, true)

	klog.V(4).Info("successfully get credentials populated for deployer")
	return secret
}

func ApplyResourceWithRetry(ctx context.Context, dynamicClient dynamic.Interface, restMapper meta.RESTMapper, resource *unstructured.Unstructured) error {
	// set UID as empty
	resource.SetUID("")

	var lastError error
	err := wait.ExponentialBackoffWithContext(ctx, retry.DefaultBackoff, func() (bool, error) {
		restMapping, err := restMapper.RESTMapping(resource.GroupVersionKind().GroupKind(), resource.GroupVersionKind().Version)
		if err != nil {
			lastError = fmt.Errorf("error===%v \n", err)
			return false, nil
		}

		if len(resource.GetNamespace()) > 0 {
			lastError = CreatNSIdNeed(dynamicClient, restMapper, resource.GetNamespace())
			if lastError != nil && !apierrors.IsAlreadyExists(lastError) {
				err = fmt.Errorf("create  ns %s error===.%v \n", lastError, err)
				return false, nil
			}
		}

		_, lastError = dynamicClient.Resource(restMapping.Resource).Namespace(resource.GetNamespace()).
			Create(context.TODO(), resource, metav1.CreateOptions{})
		if lastError == nil {
			return true, nil
		}
		if !apierrors.IsAlreadyExists(lastError) {
			return false, nil
		}

		curObj, err := dynamicClient.Resource(restMapping.Resource).Namespace(resource.GetNamespace()).
			Get(context.TODO(), resource.GetName(), metav1.GetOptions{})
		if err != nil {
			lastError = err
			return false, nil
		} else {
			lastError = nil
		}

		// try to update resource
		_, lastError = dynamicClient.Resource(restMapping.Resource).Namespace(resource.GetNamespace()).
			Update(context.TODO(), resource, metav1.UpdateOptions{})
		if lastError == nil {
			return true, nil
		}
		statusCauses, ok := getStatusCause(lastError)
		if !ok {
			lastError = fmt.Errorf("failed to get StatusCause for %s %s", resource.GetKind(), klog.KObj(resource))
			return false, nil
		}
		resourceCopy := resource.DeepCopy()
		for _, cause := range statusCauses {
			if cause.Type != metav1.CauseTypeFieldValueInvalid {
				continue
			}
			// apply immutable value
			fields := strings.Split(cause.Field, ".")
			setNestedField(resourceCopy, getNestedString(curObj.Object, fields...), fields...)
		}
		// update with immutable values applied
		_, lastError = dynamicClient.Resource(restMapping.Resource).Namespace(resourceCopy.GetNamespace()).
			Update(context.TODO(), resourceCopy, metav1.UpdateOptions{})
		if lastError == nil {
			return true, nil
		}
		return false, nil
	})

	if err == nil {
		return nil
	}
	return lastError
}

func GetDescription(ctx context.Context, dynamicClient dynamic.Interface, restMapper meta.RESTMapper, name, desNs string) (*appsv1alpha1.Description, error) {
	descriptionsKind := schema.GroupVersionKind{Group: "apps.gaia.io", Version: "v1alpha1", Kind: "Description"}
	restMapping, err := restMapper.RESTMapping(descriptionsKind.GroupKind(), descriptionsKind.Version)
	if err != nil {
		klog.Errorf("cannot get its Description, %q, err==%v", klog.KRef(desNs, name), err)
		return nil, err
	}
	curObj, queryErr := dynamicClient.Resource(restMapping.Resource).Namespace(desNs).Get(ctx, name, metav1.GetOptions{})
	if queryErr != nil && !apierrors.IsNotFound(queryErr) {
		return nil, queryErr
	}
	des := &appsv1alpha1.Description{}
	if err = UnstructuredConvertToStruct(curObj, des); err != nil {
		return nil, err
	}
	return des, nil
}

func GetNetworkRequirement(ctx context.Context, dynamicClient dynamic.Interface, restMapper meta.RESTMapper, name, desNs string) (*appsv1alpha1.NetworkRequirement, error) {
	kind := schema.GroupVersionKind{Group: "apps.gaia.io", Version: "v1alpha1", Kind: "NetworkRequirement"}
	restMapping, err := restMapper.RESTMapping(kind.GroupKind(), kind.Version)
	if err != nil {
		klog.Errorf("cannot get networkRequirement= %v", err)
		return nil, err
	}
	curObj, queryErr := dynamicClient.Resource(restMapping.Resource).Namespace(desNs).Get(ctx, name, metav1.GetOptions{})
	if queryErr != nil && !apierrors.IsNotFound(queryErr) {
		return nil, queryErr
	}
	nwr := &appsv1alpha1.NetworkRequirement{}
	if err = UnstructuredConvertToStruct(curObj, nwr); err != nil {
		return nil, err
	}
	return nwr, nil
}

func OffloadRBWorkloads(ctx context.Context, dynamicClient dynamic.Interface, restMapper meta.RESTMapper, rbLabel map[string]string) error {
	var resources []unstructured.Unstructured
	var (
		serverlessGVK     = schema.GroupVersionKind{Group: "serverless.pml.com.cn", Version: "v1", Kind: "Serverless"}
		deployGVK         = schema.GroupVersionKind{Group: "apps", Version: "v1", Kind: "Deployment"}
		affinityDaemonGVK = schema.GroupVersionKind{Group: "apps", Version: "v1", Kind: "DaemonSet"}
		cronGVK           = schema.GroupVersionKind{Group: "apps.gaia.io", Version: "v1alpha1", Kind: "CronMaster"}
		userAppGVK        = schema.GroupVersionKind{Group: "apps.gaia.io", Version: "v1alpha1", Kind: "UserAPP"}
	)
	gvks := []schema.GroupVersionKind{
		serverlessGVK, deployGVK, affinityDaemonGVK, cronGVK, userAppGVK,
	}
	for _, gvk := range gvks {
		restMapping, err := restMapper.RESTMapping(gvk.GroupKind(), gvk.Version)
		if err != nil {
			klog.Warningf("failed to get restMapping for %q, error==%v", gvk.String(), err)
			return err
		}
		unList, err := dynamicClient.Resource(restMapping.Resource).List(ctx, metav1.ListOptions{LabelSelector: labels.SelectorFromSet(labels.Set{
			known.OriginDescriptionNameLabel:      rbLabel[known.OriginDescriptionNameLabel],
			known.OriginDescriptionNamespaceLabel: rbLabel[known.OriginDescriptionNamespaceLabel],
			known.OriginDescriptionUIDLabel:       rbLabel[known.OriginDescriptionUIDLabel],
		}).String()})
		if err != nil {
			klog.Warningf("failed to list resources of %q, error==%v", gvk.String(), err)
			return err
		}
		resources = append(resources, unList.Items...)
	}

	var allErrs []error
	var err error
	wg := sync.WaitGroup{}
	errCh := make(chan error, len(resources))
	descName := rbLabel[known.OriginDescriptionNameLabel]
	for _, resource := range resources {
		wg.Add(1)
		go func(unStructure *unstructured.Unstructured) {
			defer wg.Done()
			klog.V(5).Infof("deleting %s %s defined of Description %s", unStructure.GetKind(),
				klog.KObj(unStructure), descName)
			err2 := DeleteResourceWithRetry(ctx, dynamicClient, restMapper, unStructure)
			if err2 != nil {
				klog.Infof("offload workloads name==%q err===%v \n", klog.KRef(unStructure.GetNamespace(), unStructure.GetName()), err2)
				errCh <- err2
			}
		}(&resource)
		wg.Wait()
	}

	// collect errors
	close(errCh)
	for err := range errCh {
		allErrs = append(allErrs, err)
	}
	err = utilerrors.NewAggregate(allErrs)
	if err != nil {
		klog.Errorf("failed to offload workloads", "Description", descName, "err", err)
		return err
	}

	klog.InfoS("offload workloads successfully", "Description", descName)
	return nil
}

func ApplyRBWorkloads(ctx context.Context, desc *appsv1alpha1.Description, components []appsv1alpha1.Component, parentGaiaClient *gaiaClientSet.Clientset, localDynamicClient dynamic.Interface, discoveryRESTMapper meta.RESTMapper, rb *appsv1alpha1.ResourceBinding, clusterName string) error {
	var allErrs []error
	descLabels := desc.GetLabels()
	wg := sync.WaitGroup{}
	comToBeApply := components
	errCh := make(chan error, len(comToBeApply))
	for _, com := range comToBeApply {
		switch com.Workload.Workloadtype {
		case appsv1alpha1.WorkloadTypeDeployment:
			var unStructure *unstructured.Unstructured
			var errDep error
			if com.Schedule != (appsv1alpha1.SchedulerConfig{}) {
				unStructure, errDep = AssembledCronDeploymentStructure(&com, rb.Spec.RbApps, clusterName, desc.Name, descLabels, false)
			} else {
				unStructure, errDep = AssembledDeploymentStructure(&com, rb.Spec.RbApps, clusterName, desc.Name, descLabels, false)
			}
			if errDep != nil || unStructure == nil || unStructure.Object == nil || len(unStructure.GetName()) == 0 {
				continue
			}
			wg.Add(1)
			go func(unstructure *unstructured.Unstructured) {
				defer wg.Done()
				retryErr := ApplyResourceWithRetry(ctx, localDynamicClient, discoveryRESTMapper, unstructure)
				if retryErr != nil {
					klog.Infof("applyRBWorkloads Deployment name==%q err===%v \n", klog.KRef(unstructure.GetNamespace(), unstructure.GetName()), retryErr)
					errCh <- retryErr
					return
				}
			}(unStructure)
		case appsv1alpha1.WorkloadTypeServerless:
			var unStructure *unstructured.Unstructured
			var errSer error
			if com.Schedule != (appsv1alpha1.SchedulerConfig{}) {
				unStructure, errSer = AssembledCronServerlessStructure(&com, rb.Spec.RbApps, clusterName, desc.Name, descLabels, false)
			} else {
				unStructure, errSer = AssembledServerlessStructure(&com, rb.Spec.RbApps, clusterName, desc.Name, descLabels, false)
			}
			if errSer != nil || unStructure == nil || unStructure.Object == nil || len(unStructure.GetName()) == 0 {
				continue
			}
			wg.Add(1)
			go func(unstructure *unstructured.Unstructured) {
				defer wg.Done()
				retryErr := ApplyResourceWithRetry(ctx, localDynamicClient, discoveryRESTMapper, unstructure)
				if retryErr != nil {
					klog.Infof("applyRBWorkloads Serverless name==%q err===%v \n", klog.KRef(unstructure.GetNamespace(), unstructure.GetName()), retryErr)
					errCh <- retryErr
					return
				}
			}(unStructure)
		case appsv1alpha1.WorkloadTypeAffinityDaemon:
			unstructure, errdep := AssembledDaemonSetStructure(&com, rb.Spec.RbApps, clusterName, desc.Name, descLabels, false)
			if errdep != nil || unstructure == nil || unstructure.Object == nil || len(unstructure.GetName()) == 0 {
				continue
			}
			wg.Add(1)
			go func(unstructure *unstructured.Unstructured) {
				defer wg.Done()
				retryErr := ApplyResourceWithRetry(ctx, localDynamicClient, discoveryRESTMapper, unstructure)
				if retryErr != nil {
					klog.Infof("applyRBWorkloads WorkloadTypeAffinityDaemon name==%s err===%v \n", unstructure.GetName(), retryErr)
					errCh <- retryErr
					return
				}
			}(unstructure)
		case appsv1alpha1.WorkloadTypeUserApp:
			unstructure, errUserapp := AssembledUserAppStructure(&com, rb.Spec.RbApps, clusterName, desc.Name, descLabels, false)
			if errUserapp != nil || unstructure == nil || unstructure.Object == nil || len(unstructure.GetName()) == 0 {
				continue
			}
			wg.Add(1)
			go func(unstructure *unstructured.Unstructured) {
				defer wg.Done()
				retryErr := ApplyResourceWithRetry(ctx, localDynamicClient, discoveryRESTMapper, unstructure)
				if retryErr != nil {
					klog.Infof("applyRBWorkloads userApp name==%s err===%v \n", unstructure.GetName(), retryErr)
					errCh <- retryErr
					return
				}
			}(unstructure)
		}
		wg.Wait()
	}

	// collect errors
	close(errCh)
	for err := range errCh {
		allErrs = append(allErrs, err)
	}

	condition := getCondition(allErrs, clusterName, klog.KObj(rb).String())
	// update status
	var lastError error
	err := wait.ExponentialBackoffWithContext(ctx, retry.DefaultBackoff, func() (bool, error) {
		rb.Status.Conditions = append(rb.Status.Conditions, condition)
		if rb.Status.Clusters == nil {
			rb.Status.Clusters = make(map[string]appsv1alpha1.StatusRBDeploy)
		}
		if condition.Status == metav1.ConditionFalse {
			rb.Status.Clusters[clusterName] = appsv1alpha1.ResourceBindingRed
		} else {
			rb.Status.Clusters[clusterName] = appsv1alpha1.ResourceBindingGreen
		}
		for _, status := range rb.Status.Clusters {
			if status == appsv1alpha1.ResourceBindingRed {
				rb.Status.Status = appsv1alpha1.ResourceBindingRed
				break
			}
			rb.Status.Status = appsv1alpha1.ResourceBindingGreen
		}
		_, lastError := parentGaiaClient.AppsV1alpha1().ResourceBindings(rb.Namespace).UpdateStatus(context.TODO(), rb, metav1.UpdateOptions{})
		// check if failed
		if lastError == nil {
			return true, nil
		}
		if apierrors.IsConflict(lastError) {
			newRB, lastError := parentGaiaClient.AppsV1alpha1().ResourceBindings(rb.Namespace).Get(context.TODO(), rb.Name, metav1.GetOptions{})
			if lastError == nil {
				rb = newRB
			}
		}
		return false, nil
	})
	if err != nil {
		klog.WarningDepth(2, "failed to update status of resourcebinding %q, err: %v", klog.KRef(rb.Namespace, rb.Name), lastError)
	}

	if len(allErrs) > 0 {
		return utilerrors.NewAggregate(allErrs)
	}
	return err
}

func getCondition(errs []error, clusterName, rbRef string) metav1.Condition {
	if len(errs) > 0 {
		reason := utilerrors.NewAggregate(errs).Error()
		klog.Errorf("failed to apply workloads", "ResourceBinding", rbRef, "reason", reason)
		return metav1.Condition{
			Type:               clusterName,
			Status:             metav1.ConditionFalse,
			LastTransitionTime: metav1.Now(),
			Reason:             reason,
			Message:            fmt.Sprintf("clusterName: %q ResourceBinding: %q  failed to deploy workloads", clusterName, rbRef),
		}
	}

	klog.InfoS("deploy workloads successfully", "ResourceBinding", rbRef)
	return metav1.Condition{
		Type:               clusterName,
		Status:             metav1.ConditionTrue,
		LastTransitionTime: metav1.Now(),
		Reason:             "null",
		Message:            fmt.Sprintf("clusterName: %q ResourceBinding: %q  deployed workloads successfully", clusterName, rbRef),
	}
}

func ApplyResourceBinding(ctx context.Context, localdynamicClient dynamic.Interface, discoveryRESTMapper meta.RESTMapper,
	rb *appsv1alpha1.ResourceBinding, clusterName, descriptionName, networkBindUrl string, nwr *appsv1alpha1.NetworkRequirement,
) error {
	var allErrs []error
	var err error
	errCh := make(chan error, len(rb.Spec.RbApps))
	wg := sync.WaitGroup{}
	for _, rbApp := range rb.Spec.RbApps {
		if rbApp.ClusterName == clusterName {
			newRB := &appsv1alpha1.ResourceBinding{
				TypeMeta: metav1.TypeMeta{
					Kind:       "ResourceBinding",
					APIVersion: "apps.gaia.io/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:   rb.Name,
					Labels: rb.Labels,
					Finalizers: []string{
						known.AppFinalizer,
					},
				},
				Spec: appsv1alpha1.ResourceBindingSpec{
					AppID:           rb.Spec.AppID,
					StatusScheduler: rb.Spec.StatusScheduler,
					TotalPeer:       rb.Spec.TotalPeer,
					ParentRB:        rb.Name,
					RbApps:          rbApp.Children,
					NetworkPath:     rb.Spec.NetworkPath,
				},
			}
			if len(rb.Namespace) > 0 {
				newRB.Namespace = rb.Namespace
			}
			rbUnstructured, errdep := ObjectConvertToUnstructured(newRB)
			if errdep != nil || rbUnstructured == nil {
				msg := fmt.Sprintf("apply RB in field %s failed to unmarshal resource: %v", newRB.ClusterName, errdep)
				klog.ErrorDepth(5, msg)
				allErrs = append(allErrs, errdep)
				continue
			}
			wg.Add(1)
			go func(rbUnstructured *unstructured.Unstructured) {
				defer wg.Done()
				err = ApplyResourceWithRetry(ctx, localdynamicClient, discoveryRESTMapper, rbUnstructured)
				if err != nil {
					errCh <- err
					return
				}
			}(rbUnstructured)
			wg.Wait()

			if len(newRB.Spec.NetworkPath) > 0 && len(networkBindUrl) > 0 && nwr != nil {
				klog.V(2).Infof("networkBindUrl is %q", networkBindUrl)
				if NeedBindNetworkInCluster(rb.Spec.RbApps, clusterName, nwr) {
					PostNetworkRequest(networkBindUrl, descriptionName, "add", newRB.Spec.NetworkPath[0])
				}
			}
		}
	}

	// collect errors
	close(errCh)
	for err := range errCh {
		allErrs = append(allErrs, err)
	}
	if len(allErrs) > 0 {
		err = utilerrors.NewAggregate(allErrs)
		klog.Errorf("failed to apply resourcebinding", "ResourceBinding", klog.KObj(rb), "err", err)
		return err
	}

	klog.InfoS("apply resourcebinding successfully", "ResourceBinding", klog.KObj(rb))
	return nil
}

type NetworkScheme struct {
	// whether resource reserved or not
	IsResouceReserved bool `json:"isResouceReserved,omitempty"`

	// network scheme path
	Path []byte `json:"path,omitempty"`

	// buleprint ID
	BuleprintID string `json:"buleprintID,omitempty"`
	Operate     string `json:"operate,omitempty"`
}

func PostNetworkRequest(url, descriptionName, operate string, path []byte) {
	networkScheme := NetworkScheme{
		IsResouceReserved: false,
		Path:              path,
		BuleprintID:       descriptionName,
		Operate:           operate,
	}
	data, jsonErr := json.Marshal(networkScheme)
	if jsonErr != nil {
		klog.Errorf("marshal post new network request, error=%v \n", jsonErr)
	}
	request, err := http.NewRequest("POST", url, bytes.NewBuffer(data))
	if err != nil {
		klog.Errorf("PostNetworkRequest: request post new network request, error=%v \n", err)
	}
	request.Header.Add("Content-Type", "application/json")
	request.Header.Add("cache-control", "no-cache")
	resp, respErr := http.DefaultClient.Do(request)
	if resp != nil {
		defer func(Body io.ReadCloser) {
			err := Body.Close()
			if err != nil {
				utilRuntime.HandleError(fmt.Errorf("PostNetworkRequest: failed to close response body, Description: %q ERROR: %v", descriptionName, err))
			}
		}(resp.Body)
	}
	if respErr != nil {
		klog.Errorf("PostNetworkRequest: post do sent, error====%v\n", respErr)
		return
	}

	klog.InfoS("successfully post network path", "operate", operate, "Description", descriptionName, "NetworkPath", string(path))
}

func AssembledDaemonSetStructure(com *appsv1alpha1.Component, rbApps []*appsv1alpha1.ResourceBindingApps, clusterName, descName string, descLabels map[string]string, delete bool) (*unstructured.Unstructured, error) {
	depUnstructured := &unstructured.Unstructured{}
	var err error
	comCopy := com.DeepCopy()
	for _, rbApp := range rbApps {
		if clusterName == rbApp.ClusterName && len(rbApp.Children) == 0 {
			replicas := rbApp.Replicas[comCopy.Name]
			if replicas > 0 {
				newLabels := addLabels(comCopy, descLabels, descName)
				ds := &appsv1.DaemonSet{
					TypeMeta: metav1.TypeMeta{
						Kind:       "DaemonSet",
						APIVersion: "apps/v1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Labels: newLabels,
					},
				}
				if len(comCopy.Namespace) > 0 {
					ds.Namespace = comCopy.Namespace
				} else {
					ds.Namespace = metav1.NamespaceDefault
				}
				ds.Name = comCopy.Name

				if !delete {
					ds.Spec.Template = comCopy.Module
					nodeAffinity := AddNodeAffinity(comCopy)
					ds.Spec.Template.Spec.Affinity = nodeAffinity

					label := ds.GetLabels()
					ds.Spec.Template.Labels = label
					ds.Spec.Selector = &metav1.LabelSelector{MatchLabels: label}
					// add  env variables log needed
					ds.Spec.Template.Spec.Containers = addEnvVars(comCopy.Module.Spec.Containers, com.Scc)

					depUnstructured, err = ObjectConvertToUnstructured(ds)
				} else {
					depUnstructured, err = ObjectConvertToUnstructured(ds)
				}
			}
			break
		}
	}

	if err != nil {
		msg := fmt.Sprintf("deamonset failed to unmarshal resource: %v", err)
		klog.ErrorDepth(5, msg)
		return nil, err
	}
	return depUnstructured, nil
}

func AssembledUserAppStructure(com *appsv1alpha1.Component, rbApps []*appsv1alpha1.ResourceBindingApps, clusterName, descName string, descLabels map[string]string, delete bool) (*unstructured.Unstructured, error) {
	depUnstructured := &unstructured.Unstructured{}
	var err error
	comCopy := com.DeepCopy()
	for _, rbApp := range rbApps {
		if clusterName == rbApp.ClusterName && len(rbApp.Children) == 0 {
			replicas := rbApp.Replicas[comCopy.Name]
			if replicas == 0 {
				return nil, nil
			}
			newLabels := addLabels(comCopy, descLabels, descName)
			userAPP := &appsv1alpha1.UserAPP{
				TypeMeta: metav1.TypeMeta{
					Kind:       "UserAPP",
					APIVersion: "apps.gaia.io/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Labels: newLabels,
				},
			}
			userAPP.Name = comCopy.Name
			if !delete {
				userAPP.Spec.Module = comCopy.Module
				userAPP.Spec.SN = comCopy.Workload.TraitUserAPP.SN
				label := userAPP.GetLabels()
				userAPP.Spec.Module.Labels = label
				// add  env variables log needed
				userAPP.Spec.Module.Spec.Containers = addEnvVars(comCopy.Module.Spec.Containers, com.Scc)

				depUnstructured, err = ObjectConvertToUnstructured(userAPP)
			} else {
				depUnstructured, err = ObjectConvertToUnstructured(userAPP)
			}
			break
		}
	}

	if err != nil {
		msg := fmt.Sprintf("userAPP failed to unmarshal resource: %v", err)
		klog.ErrorDepth(5, msg)
		return nil, err
	}
	return depUnstructured, nil
}

func AddNodeAffinity(com *appsv1alpha1.Component) *corev1.Affinity {
	nodeAffinity := &corev1.Affinity{
		NodeAffinity: &corev1.NodeAffinity{
			PreferredDuringSchedulingIgnoredDuringExecution: []corev1.PreferredSchedulingTerm{{
				Weight: 2,
				Preference: corev1.NodeSelectorTerm{
					MatchExpressions: []corev1.NodeSelectorRequirement{{
						Key:      v1alpha1.ParsedResFormKey,
						Operator: corev1.NodeSelectorOpIn,
						Values:   []string{"pool", "Pool"},
					}},
				},
			}},
		},
	}

	if com.Workload.Workloadtype == appsv1alpha1.WorkloadTypeAffinityDaemon {
		if len(com.Workload.TraitAffinityDaemon.SNS) > 0 {
			nodeSelectorTermSNs := corev1.NodeSelectorTerm{
				MatchExpressions: []corev1.NodeSelectorRequirement{{
					Key:      v1alpha1.ParsedSNKey,
					Operator: corev1.NodeSelectorOpIn,
					Values:   com.Workload.TraitAffinityDaemon.SNS,
				}},
			}
			if nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == nil {
				nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution = &corev1.NodeSelector{}
			}
			if nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms == nil {
				nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms = make([]corev1.NodeSelectorTerm, 0)
			}
			nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms = append(nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms, nodeSelectorTermSNs)
			return nodeAffinity
		}
	}

	if len(com.SchedulePolicy.Level) > 0 {
		nodeSelectorTerms := setNodeSelectorTerms(com.SchedulePolicy.Level[appsv1alpha1.SchedulePolicyMandatory].MatchExpressions)
		if len(nodeSelectorTerms) > 0 {
			if nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == nil {
				nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution = &corev1.NodeSelector{}
			}
			if nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms == nil {
				nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms = []corev1.NodeSelectorTerm{}
			}
			nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms = append(nodeAffinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms, nodeSelectorTerms...)
		}
	}

	return nodeAffinity
}

func AssembledDeploymentStructure(com *appsv1alpha1.Component, rbApps []*appsv1alpha1.ResourceBindingApps, clusterName, descName string, descLabels map[string]string, delete bool) (*unstructured.Unstructured, error) {
	depUnstructured := &unstructured.Unstructured{}
	var err error
	comCopy := com.DeepCopy()
	for _, rbApp := range rbApps {
		if clusterName == rbApp.ClusterName && len(rbApp.Children) == 0 {
			replicas := rbApp.Replicas[comCopy.Name]
			if replicas <= 0 {
				return nil, fmt.Errorf("deployment name==%s, have zero replicas", comCopy.Name)
			}
			newLabels := addLabels(comCopy, descLabels, descName)
			dep := &appsv1.Deployment{
				TypeMeta: metav1.TypeMeta{
					Kind:       "Deployment",
					APIVersion: "apps/v1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Labels: newLabels,
				},
			}
			if len(comCopy.Namespace) > 0 {
				dep.Namespace = comCopy.Namespace
			} else {
				dep.Namespace = metav1.NamespaceDefault
			}
			dep.Name = comCopy.Name
			if !delete {
				dep.Spec.Template = comCopy.Module
				nodeAffinity := AddNodeAffinity(comCopy)
				dep.Spec.Template.Spec.Affinity = nodeAffinity
				if dep.Spec.Template.Spec.NodeSelector == nil {
					dep.Spec.Template.Spec.NodeSelector = map[string]string{
						v1alpha1.ParsedRuntimeStateKey: comCopy.RuntimeType,
					}
				}
				dep.Spec.Replicas = &replicas
				label := dep.GetLabels()
				dep.Spec.Template.Labels = label
				dep.Spec.Selector = &metav1.LabelSelector{MatchLabels: label}
				// add  env variables log needed
				dep.Spec.Template.Spec.Containers = addEnvVars(comCopy.Module.Spec.Containers, com.Scc)

				depUnstructured, err = ObjectConvertToUnstructured(dep)
			} else {
				depUnstructured, err = ObjectConvertToUnstructured(dep)
			}
			break
		}
	}

	if err != nil {
		msg := fmt.Sprintf("deployment failed to unmarshal resource: %v", err)
		klog.ErrorDepth(5, msg)
		return nil, err
	}

	return depUnstructured, nil
}

func addLabels(com *appsv1alpha1.Component, descLabels map[string]string, descName string) map[string]string {
	newLabels := map[string]string{
		known.GaiaDescriptionLabel:            descName,
		known.GaiaComponentLabel:              com.Name,
		known.OriginDescriptionNameLabel:      descLabels[known.OriginDescriptionNameLabel],
		known.OriginDescriptionNamespaceLabel: descLabels[known.OriginDescriptionNamespaceLabel],
		known.OriginDescriptionUIDLabel:       descLabels[known.OriginDescriptionUIDLabel],
	}
	if descLabels[known.UserIDLabel] != "" {
		newLabels[known.UserIDLabel] = descLabels[known.UserIDLabel]
	}
	for k, v := range com.Module.Labels {
		newLabels[k] = v
	}

	return newLabels
}

func addEnvVars(containers []corev1.Container, scc []appsv1alpha1.SccConfig) []corev1.Container {
	// add env variables log needed
	env := []corev1.EnvVar{
		{
			Name: "HYPEROS_COMPONET",
			ValueFrom: &corev1.EnvVarSource{
				FieldRef: &corev1.ObjectFieldSelector{
					FieldPath: "metadata.labels['apps.gaia.io/component']",
				},
			},
		},
		{
			Name: "HYPEROS_BLUEPRINT",
			ValueFrom: &corev1.EnvVarSource{
				FieldRef: &corev1.ObjectFieldSelector{
					FieldPath: "metadata.labels['apps.gaia.io/description']",
				},
			},
		},
		{
			Name: "HYPEROS_LOG_SERVER",
			ValueFrom: &corev1.EnvVarSource{
				FieldRef: &corev1.ObjectFieldSelector{
					FieldPath: "status.hostIP",
				},
			},
		},
		{
			Name:  "HYPEROS_LOG_SERVER_PORT",
			Value: "12201",
		},
	}
	// add scc env variables
	if len(scc) > 0 {
		for k := range scc {
			env = append(env, corev1.EnvVar{
				Name:  makeEnvVariableName(scc[k].ScnID),
				Value: scc[k].Scc,
			})
		}
	}
	for k := range containers {
		containers[k].Env = append(containers[k].Env, env...)
	}
	return containers
}

func makeEnvVariableName(str string) string {
	// TODO: If we simplify to "all names are DNS1123Subdomains" this
	// will need two tweaks:
	//   1) Handle leading digits
	//   2) Handle dots
	return strings.ToUpper(strings.Replace(str, "-", "_", -1))
}

func setMatchExpressions(matchExpressions []metav1.LabelSelectorRequirement) []corev1.NodeSelectorRequirement {
	nsRequirements := []corev1.NodeSelectorRequirement{}
	for _, expression := range matchExpressions {
		express := corev1.NodeSelectorRequirement{
			Key:      known.SpecificNodeLabelsKeyPrefix + expression.Key,
			Operator: corev1.NodeSelectorOperator(expression.Operator),
			Values:   expression.Values,
		}
		nsRequirements = append(nsRequirements, express)
	}
	return nsRequirements
}

func setNodeSelectorTerms(matchExpressions []metav1.LabelSelectorRequirement) []corev1.NodeSelectorTerm {
	nsRequirements := setMatchExpressions(matchExpressions)
	nodeSelectorTerms := []corev1.NodeSelectorTerm{}
	nodeSelectorTerm := corev1.NodeSelectorTerm{
		MatchExpressions: nsRequirements,
	}
	if len(nsRequirements) > 0 {
		nodeSelectorTerms = append(nodeSelectorTerms, nodeSelectorTerm)
	}
	return nodeSelectorTerms
}

func AssembledCronDeploymentStructure(com *appsv1alpha1.Component, rbApps []*appsv1alpha1.ResourceBindingApps, clusterName, descName string, descLabels map[string]string, delete bool) (*unstructured.Unstructured, error) {
	cronUnstructured := &unstructured.Unstructured{}
	var err error
	comCopy := com.DeepCopy()
	for _, rbApp := range rbApps {
		if clusterName == rbApp.ClusterName && len(rbApp.Children) == 0 {
			replicas := rbApp.Replicas[comCopy.Name]
			if replicas > 0 {
				newLabels := addLabels(comCopy, descLabels, descName)
				cron := &appsv1alpha1.CronMaster{
					TypeMeta: metav1.TypeMeta{
						Kind:       "CronMaster",
						APIVersion: "apps.gaia.io/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Labels: newLabels,
					},
				}
				if len(comCopy.Namespace) > 0 {
					cron.Namespace = comCopy.Namespace
				} else {
					cron.Namespace = metav1.NamespaceDefault
				}
				cron.Name = comCopy.Name

				if !delete {
					cron.Spec = appsv1alpha1.CronMasterSpec{
						Schedule: comCopy.Schedule,
						Resource: appsv1alpha1.ReferenceResource{
							Namespace: comCopy.Namespace,
							Name:      comCopy.Name,
							Kind:      "Deployment",
							Version:   "v1",
							Group:     "apps",
						},
					}
					// construct ReferenceResource.RawData
					dep := &appsv1.Deployment{
						TypeMeta: metav1.TypeMeta{
							Kind:       "Deployment",
							APIVersion: "apps/v1",
						},
						ObjectMeta: metav1.ObjectMeta{
							Labels: newLabels,
						},
					}
					if len(comCopy.Namespace) > 0 {
						dep.Namespace = comCopy.Namespace
					} else {
						dep.Namespace = metav1.NamespaceDefault
					}
					dep.Name = comCopy.Name
					dep.Spec.Template = comCopy.Module
					nodeAffinity := AddNodeAffinity(comCopy)
					dep.Spec.Template.Spec.Affinity = nodeAffinity
					if dep.Spec.Template.Spec.NodeSelector == nil {
						dep.Spec.Template.Spec.NodeSelector = map[string]string{
							v1alpha1.ParsedRuntimeStateKey: comCopy.RuntimeType,
						}
					}
					dep.Spec.Replicas = &replicas
					label := dep.GetLabels()
					dep.Spec.Template.Labels = label
					dep.Spec.Selector = &metav1.LabelSelector{MatchLabels: label}
					// add  env variables log needed
					dep.Spec.Template.Spec.Containers = addEnvVars(comCopy.Module.Spec.Containers, com.Scc)

					depJs, errDep := json.Marshal(dep)
					if errDep != nil {
						msg := fmt.Sprintf("deployment %q failed to marshal resource: %v", klog.KRef(dep.GetNamespace(), dep.GetName()), errDep)
						klog.ErrorDepth(5, msg)
						return nil, errDep
					}
					cron.Spec.Resource.RawData = depJs

					cronUnstructured, err = ObjectConvertToUnstructured(cron)
				} else {
					cronUnstructured, err = ObjectConvertToUnstructured(cron)
				}
			}
			break
		}
	}
	if err != nil {
		msg := fmt.Sprintf("deployment failed to unmarshal resource: %v", err)
		klog.ErrorDepth(5, msg)
		return nil, err
	}
	return cronUnstructured, nil
}

func AssembledCronServerlessStructure(com *appsv1alpha1.Component, rbApps []*appsv1alpha1.ResourceBindingApps, clusterName, descName string, descLabels map[string]string, delete bool) (*unstructured.Unstructured, error) {
	cronUnstructured := &unstructured.Unstructured{}
	var err error
	comCopy := com.DeepCopy()
	for _, rbApp := range rbApps {
		if clusterName == rbApp.ClusterName && len(rbApp.Children) == 0 {
			replicas := rbApp.Replicas[comCopy.Name]
			if replicas > 0 {
				newLabels := addLabels(comCopy, descLabels, descName)
				cron := &appsv1alpha1.CronMaster{
					TypeMeta: metav1.TypeMeta{
						Kind:       "CronMaster",
						APIVersion: "apps.gaia.io/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Labels: newLabels,
					},
				}
				if len(comCopy.Namespace) > 0 {
					cron.Namespace = comCopy.Namespace
				} else {
					cron.Namespace = metav1.NamespaceDefault
				}
				cron.Name = comCopy.Name

				if !delete {
					cron.Spec = appsv1alpha1.CronMasterSpec{
						Schedule: comCopy.Schedule,
						Resource: appsv1alpha1.ReferenceResource{
							Namespace: comCopy.Namespace,
							Name:      comCopy.Name,
							Kind:      "Serverless",
							Version:   "v1",
							Group:     "serverless.pml.com.cn",
						},
					}
					// construct ReferenceResource.RawData
					comCopy.Workload.TraitServerless.Foundingmember = rbApp.ChosenOne[comCopy.Name] == 1
					ser := &lmmserverless.Serverless{
						TypeMeta: metav1.TypeMeta{
							Kind:       "Serverless",
							APIVersion: "serverless.pml.com.cn/v1",
						},
						ObjectMeta: metav1.ObjectMeta{
							Labels: newLabels,
						},
					}
					if len(comCopy.Namespace) > 0 {
						ser.Namespace = comCopy.Namespace
					} else {
						ser.Namespace = metav1.NamespaceDefault
					}
					ser.Name = comCopy.Name
					ser.Spec = lmmserverless.ServerlessSpec{
						Namespace:   comCopy.Namespace,
						Name:        comCopy.Name,
						RuntimeType: comCopy.RuntimeType,
						Module:      comCopy.Module,
						Workload: lmmserverless.Workload{
							Workloadtype:    lmmserverless.WorkloadType(comCopy.Workload.Workloadtype),
							TraitServerless: comCopy.Workload.TraitServerless,
						},
					}
					nodeAffinity := AddNodeAffinity(comCopy)
					ser.Spec.Module.Spec.Affinity = nodeAffinity
					// add  env variables log needed
					ser.Spec.Module.Spec.Containers = addEnvVars(comCopy.Module.Spec.Containers, com.Scc)
					if ser.Spec.Module.Spec.NodeSelector == nil {
						ser.Spec.Module.Spec.NodeSelector = map[string]string{
							known.HypernodeClusterNodeRole: known.HypernodeClusterNodeRolePublic,
							v1alpha1.ParsedRuntimeStateKey: comCopy.RuntimeType,
						}
					}
					ser.Spec.Module.Labels = ser.GetLabels()

					serJs, errSer := json.Marshal(ser)
					if errSer != nil {
						msg := fmt.Sprintf("serverless %q failed to marshal resource: %v", klog.KRef(ser.GetNamespace(), ser.GetName()), errSer)
						klog.ErrorDepth(5, msg)
						return nil, errSer
					}
					cron.Spec.Resource.RawData = serJs

					cronUnstructured, err = ObjectConvertToUnstructured(cron)
				} else {
					cronUnstructured, err = ObjectConvertToUnstructured(cron)
				}
			}
			break
		}
	}
	if err != nil {
		msg := fmt.Sprintf("serverless failed to unmarshal resource: %v", err)
		klog.ErrorDepth(5, msg)
		return nil, err
	}
	return cronUnstructured, nil
}

func AssembledServerlessStructure(com *appsv1alpha1.Component, rbApps []*appsv1alpha1.ResourceBindingApps, clusterName, descName string, descLabels map[string]string, delete bool) (*unstructured.Unstructured, error) {
	serUnstructured := &unstructured.Unstructured{}
	var err error
	comCopy := com.DeepCopy()
	for _, rbApp := range rbApps {
		if clusterName == rbApp.ClusterName && len(rbApp.Children) == 0 {
			replicas := rbApp.Replicas[comCopy.Name]
			comCopy.Workload.TraitServerless.Foundingmember = rbApp.ChosenOne[comCopy.Name] == 1
			if replicas > 0 {
				newLabels := addLabels(comCopy, descLabels, descName)
				ser := &lmmserverless.Serverless{
					TypeMeta: metav1.TypeMeta{
						Kind:       "Serverless",
						APIVersion: "serverless.pml.com.cn/v1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Labels: newLabels,
					},
				}
				if len(comCopy.Namespace) > 0 {
					ser.Namespace = comCopy.Namespace
				} else {
					ser.Namespace = metav1.NamespaceDefault
				}
				ser.Name = comCopy.Name

				if !delete {
					ser.Spec = lmmserverless.ServerlessSpec{
						Namespace:   comCopy.Namespace,
						Name:        comCopy.Name,
						RuntimeType: comCopy.RuntimeType,
						Module:      comCopy.Module,
						Workload: lmmserverless.Workload{
							Workloadtype:    lmmserverless.WorkloadType(comCopy.Workload.Workloadtype),
							TraitServerless: comCopy.Workload.TraitServerless,
						},
					}
					nodeAffinity := AddNodeAffinity(comCopy)
					ser.Spec.Module.Spec.Affinity = nodeAffinity
					// add  env variables log needed
					ser.Spec.Module.Spec.Containers = addEnvVars(comCopy.Module.Spec.Containers, com.Scc)
					if ser.Spec.Module.Spec.NodeSelector == nil {
						ser.Spec.Module.Spec.NodeSelector = map[string]string{
							known.HypernodeClusterNodeRole: known.HypernodeClusterNodeRolePublic,
							v1alpha1.ParsedRuntimeStateKey: comCopy.RuntimeType,
						}
					}
					ser.Spec.Module.Labels = ser.GetLabels()

					serUnstructured, err = ObjectConvertToUnstructured(ser)
				} else {
					serUnstructured, err = ObjectConvertToUnstructured(ser)
				}
			}
			break
		}
	}
	if err != nil {
		msg := fmt.Sprintf("serverless failed to unmarshal resource: %v", err)
		klog.ErrorDepth(5, msg)
		return nil, err
	}
	return serUnstructured, nil
}

func ConstructDescriptionFromExistOne(old *appsv1alpha1.Description) *appsv1alpha1.Description {
	newOne := &appsv1alpha1.Description{
		ObjectMeta: metav1.ObjectMeta{
			Name:       old.Name,
			Finalizers: old.Finalizers,
			Labels:     fillDescriptionLabels(old),
		},
		Spec: old.Spec,
	}
	return newOne
}

func fillDescriptionLabels(desc *appsv1alpha1.Description) map[string]string {
	newLabels := make(map[string]string)
	oldLabels := desc.GetLabels()
	if len(oldLabels) != 0 {
		for key, value := range oldLabels {
			newLabels[key] = value
		}
	}
	if desc.Namespace == known.GaiaReservedNamespace {
		newLabels[known.OriginDescriptionNameLabel] = desc.Name
		newLabels[known.OriginDescriptionNamespaceLabel] = desc.Namespace
		newLabels[known.OriginDescriptionUIDLabel] = string(desc.UID)
	}
	return newLabels
}

func CreatNSIdNeed(dynamicClient dynamic.Interface, restMapper meta.RESTMapper, namespace string) error {
	var err error
	if len(namespace) > 0 {
		ns := &corev1.Namespace{
			TypeMeta: metav1.TypeMeta{
				Kind:       "Namespace",
				APIVersion: "v1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name: namespace,
			},
		}
		nsKind := schema.GroupVersionKind{Group: "", Version: "v1", Kind: "Namespace"}
		restNS, _ := restMapper.RESTMapping(nsKind.GroupKind(), nsKind.Version)
		nsUnstructured, errns := ObjectConvertToUnstructured(ns)
		if errns != nil {
			err := fmt.Errorf("convert ns %s error===.%v \n", namespace, err)
			return err
		}
		_, err := dynamicClient.Resource(restNS.Resource).Create(context.TODO(), nsUnstructured, metav1.CreateOptions{})
		if err != nil && !apierrors.IsAlreadyExists(err) {
			nsErr := fmt.Errorf("create  ns %s error===.%v \n", namespace, err)
			return nsErr
		}
	}
	return nil
}

// OffloadResourceByDescription offloads the specified resource
func OffloadResourceByDescription(ctx context.Context, dynamicClient dynamic.Interface,
	discoveryRESTMapper meta.RESTMapper, desc *appsv1alpha1.Description,
) error {
	descriptionsKind := schema.GroupVersionKind{Group: "apps.gaia.io", Version: "v1alpha1", Kind: "ResourceBinding"}
	restMapping, err := discoveryRESTMapper.RESTMapping(descriptionsKind.GroupKind(), descriptionsKind.Version)
	if err != nil {
		klog.Errorf("cannot get desc name=%s its descrito %v", desc.Name, err)
		return err
	}

	klog.V(5).Infof("deleting description %s  defined in deploy %s", desc.Name, klog.KObj(desc))
	err = dynamicClient.Resource(restMapping.Resource).Namespace(desc.Namespace).DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{LabelSelector: labels.SelectorFromSet(labels.Set{
		known.GaiaDescriptionLabel: desc.Name,
	}).String()})
	if err != nil && !apierrors.IsNotFound(err) {
		klog.Errorf("deleting description %s  defined in deploy %s", desc.Name, klog.KObj(desc))
		return err
	}
	return err
}

func OffloadDescription(ctx context.Context, dynamicClient dynamic.Interface,
	discoveryRESTMapper meta.RESTMapper, desc *appsv1alpha1.Description,
) error {
	descUnstructured, _ := ObjectConvertToUnstructured(desc)
	return DeleteResource(ctx, dynamicClient, discoveryRESTMapper, descUnstructured)
}

func DeleteResource(ctx context.Context, dynamicClient dynamic.Interface,
	discoveryRESTMapper meta.RESTMapper, resource *unstructured.Unstructured,
) error {
	wg := sync.WaitGroup{}
	var err error
	wg.Add(1)
	go func(resource *unstructured.Unstructured) {
		defer wg.Done()
		klog.V(5).Infof("resource deleting %s %s defined in resource %s", resource.GetKind(),
			resource.GetName(), klog.KObj(resource))
		err = DeleteResourceWithRetry(ctx, dynamicClient, discoveryRESTMapper, resource)
		if err != nil {
			klog.Errorf("error resource deleting %s %s defined in resource %s", resource.GetKind(),
				resource.GetName(), klog.KObj(resource))
			return
		}
	}(resource)
	wg.Wait()
	return err
}

func ApplyResource(ctx context.Context, dynamicClient dynamic.Interface,
	discoveryRESTMapper meta.RESTMapper, resource *unstructured.Unstructured,
) error {
	wg := sync.WaitGroup{}
	var err error
	wg.Add(1)
	go func(resource *unstructured.Unstructured) {
		defer wg.Done()
		klog.V(5).Infof("resource apply %s %s defined in resource %s", resource.GetKind(),
			resource.GetName(), klog.KObj(resource))
		err = ApplyResourceWithRetry(ctx, dynamicClient, discoveryRESTMapper, resource)
		if err != nil {
			klog.Errorf("error resource apply %s %s defined in resource %s", resource.GetKind(),
				resource.GetName(), klog.KObj(resource))
			return
		}
	}(resource)
	wg.Wait()
	return err
}

// NeedBindNetworkInCluster check if we should bind network path.
func NeedBindNetworkInCluster(rbApps []*appsv1alpha1.ResourceBindingApps, clusterName string, networkReq *appsv1alpha1.NetworkRequirement) bool {
	var compToReplicasMap map[string]int32
	for _, rbApp := range rbApps {
		if clusterName == rbApp.ClusterName {
			compToReplicasMap = rbApp.Replicas
		}
	}
	idToComponentMap := make(map[string]string)
	for _, scn := range networkReq.Spec.WorkloadComponents.Scns {
		for _, selfID := range scn.SelfID {
			idToComponentMap[selfID] = scn.Name
		}
	}

	if len(networkReq.Spec.WorkloadComponents.Links) > 0 {
		for _, link := range networkReq.Spec.WorkloadComponents.Links {
			comNameSrc := idToComponentMap[link.SourceID]
			comNameDst := idToComponentMap[link.DestinationID]
			if compToReplicasMap[comNameSrc] > 0 || compToReplicasMap[comNameDst] > 0 {
				return true
			}
		}
	}

	return false
}

func CreateRBtoParentWithRetry(ctx context.Context, gaiaClient *gaiaClientSet.Clientset, namespace string, rb *appsv1alpha1.ResourceBinding) {
	var lastError error
	err := wait.ExponentialBackoffWithContext(ctx, retry.DefaultBackoff, func() (bool, error) {
		_, lastError := gaiaClient.AppsV1alpha1().ResourceBindings(namespace).Create(context.TODO(), rb, metav1.CreateOptions{})
		if lastError == nil {
			return true, nil
		}
		if !apierrors.IsAlreadyExists(lastError) {
			return false, nil
		}
		_, err := gaiaClient.AppsV1alpha1().ResourceBindings(namespace).Get(ctx, rb.GetName(), metav1.GetOptions{})
		if err != nil {
			lastError = err
			return false, nil
		} else {
			lastError = nil
		}
		return true, nil
	})
	if err != nil {
		klog.WarningDepth(2, "failed to create ResourceBinding %q to parent cluster, ERROR: %v, err is ", klog.KObj(rb), lastError)
	} else {
		klog.Infof("successfully created ResourceBinding %q to parent cluster", klog.KObj(rb))
	}
}
